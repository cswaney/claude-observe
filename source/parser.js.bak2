import fs from 'fs';
import path from 'path';

/**
 * Parse Claude JSONL log files and convert to UI format
 */

// Convert ISO timestamp to HH:MM:SS format
function formatTimestamp(isoString) {
	if (!isoString) return '00:00:00';
	const date = new Date(isoString);
	const hours = String(date.getHours()).padStart(2, '0');
	const minutes = String(date.getMinutes()).padStart(2, '0');
	const seconds = String(date.getSeconds()).padStart(2, '0');
	return `${hours}:${minutes}:${seconds}`;
}

// Calculate total tokens from usage object
function getTotalUsage(usage) {
	if (!usage) return 0;
	const input = usage.input_tokens || 0;
	const output = usage.output_tokens || 0;
	const cacheRead = usage.cache_read_input_tokens || 0;
	const cacheCreation = usage.cache_creation_input_tokens || 0;
	return input + output + cacheRead + cacheCreation;
}

// Read and parse a JSONL file
function readJsonl(filePath) {
	const content = fs.readFileSync(filePath, 'utf-8');
	const lines = content.split('\n').filter(line => line.trim());
	return lines.map(line => JSON.parse(line));
}

/**
 * Parse log entries from a single file
 */
export function parseLogFile(filePath) {
	const entries = readJsonl(filePath);
	const logs = [];

	for (const entry of entries) {
		// Skip summary and file-history-snapshot entries
		if (entry.type === 'summary' || entry.type === 'file-history-snapshot' || entry.type === 'queue-operation') {
			continue;
		}

		// Handle user and assistant messages
		if (entry.type === 'user' || entry.type === 'assistant') {
			const message = entry.message;
			if (!message || !message.content) continue;

			// Process each content block
			for (const content of message.content) {
				if (content.type === 'text') {
					logs.push({
						uuid: entry.uuid,
						type: entry.type,
						timestamp: formatTimestamp(entry.timestamp),
						isoTimestamp: entry.timestamp,
						content: content.text,
						collapsed: true,
						usage: getTotalUsage(message.usage),
					});
				} else if (content.type === 'thinking') {
					logs.push({
						uuid: entry.uuid,
						type: 'thinking',
						timestamp: formatTimestamp(entry.timestamp),
					isoTimestamp: entry.timestamp,						content: content.thinking,
						collapsed: true,
						usage: getTotalUsage(message.usage),
					});
				} else if (content.type === 'tool_use') {
					logs.push({
						uuid: entry.uuid,
						type: 'tool',
						timestamp: formatTimestamp(entry.timestamp),
						content: `${content.name}`,
						collapsed: true,
						usage: getTotalUsage(message.usage),
					});
				}
				// Note: tool_result will be handled separately if needed
			}
		}
	}

	return logs;
}

/**
 * Parse an agent log file and create start/end entries
 */
function parseAgentFile(filePath) {
	const entries = readJsonl(filePath);
	const logs = [];

	if (entries.length === 0) return logs;

	// Get agent ID from first entry
	const agentId = entries[0].agentId;
	if (!agentId) return logs;

	// Find first and last timestamps
	const timestamps = entries
		.filter(e => e.timestamp)
		.map(e => e.timestamp);

	if (timestamps.length === 0) return logs;

	const firstTimestamp = timestamps[0];
	const lastTimestamp = timestamps[timestamps.length - 1];

	// Create agent start entry
	logs.push({
		uuid: `${agentId}-start`,
		type: 'subagent',
		timestamp: formatTimestamp(firstTimestamp),
		agentId: agentId,
		content: `Agent ${agentId} started`,
		collapsed: true,
		usage: 0,
		isLast: false,
	});

	// Create agent end entry
	logs.push({
		uuid: `${agentId}-end`,
		type: 'subagent',
		timestamp: formatTimestamp(lastTimestamp),
		agentId: agentId,
		content: `Agent ${agentId} completed`,
		collapsed: true,
		usage: 0,
		isLast: true,
	});

	return logs;
}

/**
 * Parse logs from a session directory or file path
 * @param {string} sessionDir - Directory containing session files
 * @param {string} sessionId - Optional session ID to parse (without .jsonl extension)
 * @param {string} sessionPath - Optional direct path to session file (takes precedence)
 */
export function parseSession(sessionDir, sessionId = null, sessionPath = null) {
	let mainFilePath;
	let currentSessionDir;

	if (sessionPath) {
		// Load from direct file path
		mainFilePath = sessionPath;
		currentSessionDir = path.dirname(sessionPath);
	} else {
		// Load from sessionDir/sessionId
		const files = fs.readdirSync(sessionDir);

		// Find main session file
		let mainFile;
		if (sessionId) {
			mainFile = `${sessionId}.jsonl`;
			if (!files.includes(mainFile)) {
				throw new Error(`Session file ${mainFile} not found`);
			}
		} else {
			// Find first non-agent file
			mainFile = files.find(f => f.endsWith('.jsonl') && !f.startsWith('agent-'));
			if (!mainFile) {
				throw new Error('No main session file found');
			}
		}

		mainFilePath = path.join(sessionDir, mainFile);
		currentSessionDir = sessionDir;
	}

	// Parse main logs
	const logs = parseLogFile(mainFilePath);

	// Get session ID from the main file name (without .jsonl extension)
	const currentSessionId = path.basename(mainFilePath, '.jsonl');

	// Parse agent files that belong to this session
	const allFiles = fs.readdirSync(currentSessionDir);
	const agentFiles = allFiles.filter(f => f.startsWith('agent-') && f.endsWith('.jsonl'));
	for (const agentFile of agentFiles) {
		const agentPath = path.join(currentSessionDir, agentFile);

		// Read first line to check if this agent belongs to this session
		const firstLine = fs.readFileSync(agentPath, 'utf-8').split('\n')[0];
		if (!firstLine.trim()) continue;

		try {
			const firstEntry = JSON.parse(firstLine);
			// Only parse if this agent belongs to the current session
			if (firstEntry.sessionId === currentSessionId) {
				const agentLogs = parseAgentFile(agentPath);
				logs.push(...agentLogs);
			}
		} catch (e) {
			// Skip invalid JSON
			continue;
		}
	}

	// Sort by timestamp
	logs.sort((a, b) => {
		if (a.timestamp < b.timestamp) return -1;
		if (a.timestamp > b.timestamp) return 1;
		return 0;
	});

	// Assign sequential IDs
	logs.forEach((log, index) => {
		log.id = index + 1;
	});

	// Extract project name from directory path
	// Format: ~/.claude/projects/something-with-project-name
	const dirName = path.basename(currentSessionDir);
	const projectName = dirName.replace(/-/g, ' ').replace(/^\./, '');

	// Get start datetime from first log
	const startDatetime = logs.length > 0 && logs[0].isoTimestamp ? new Date(logs[0].isoTimestamp).toLocaleString() : null;

	return {
		logs,
		sessionId: currentSessionId,
		project: projectName,
		startDatetime,
	};
}
